<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>炎色反応シミュレーション — Strong Flame on Light BG</title>
<style>
  html, body { margin:0; height:100%; background:#000; color:#111; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;}
  #app { display:grid; grid-template-rows:auto 1fr auto; height:100vh; }
  header, footer { padding:8px 12px; background:#f6f6f6; border-bottom:1px solid #ddd; }
  footer { border-top:1px solid #ddd; border-bottom:none; }
  .title { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .tag { font-size:12px; padding:2px 8px; border:1px solid #bbb; border-radius:999px; color:#555; background:#fff; }
  #controls { display:flex; align-items:center; gap:12px; padding:6px 0; flex-wrap:wrap; }
  label { font-size:13px; color:#333; }
  input[type="range"] { width: 220px; max-width: 52vw; }
  select, button { background:#fff; color:#111; border:1px solid #bbb; border-radius:8px; padding:6px 10px; cursor:pointer; }
  button:active { transform: translateY(1px); }
  #stageWrap { display:flex; align-items:center; justify-content:center; padding: 6px 0; background:#000; }
  canvas { background:#000; border-radius: 12px; border:1px solid #ccc; display:block; width:100%; height:auto; touch-action:none; }
  .legend { font-size:12px; color:#444; opacity:0.95; }
  @media (max-width: 640px) {
    input[type="range"]{ width: 150px; }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <strong>炎色反応シミュレーション（Light BG強調版）</strong>
      <span class="tag">背景切替</span>
      <span class="tag">濃い炎色</span>
      <span class="tag">自動リターン</span>
    </div>
    <div id="controls">
      <label for="bgSel">背景</label>
      <select id="bgSel">
        <option value="black" selected>黒</option>
        <option value="white">白</option>
        <option value="hawaii">ハワイ</option>
      </select>
      <label for="conc">濃度 C（mol/L）</label>
      <input id="conc" type="range" min="0.00" max="1.00" step="0.01" value="0.85">
      <span id="concVal">0.85</span>
      <button id="resetBtn">初期化</button>
      <span class="legend">下のビーカー（記号のみ）をドラッグ → 中央へ。次の投入で自動リターン。</span>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="scene" aria-label="炎色反応ステージ"></canvas>
  </div>

  <footer>
    <div class="legend">
      I(λ,t)=C·f(T)·Σ a_i·exp(-(λ-λ_i)^2/2σ^2)·exp(-t/τ)（λ[nm], t[s], C[mol/L], σ[nm], τ[s], f(T)=T/1600）。
      明るい背景では「背面ビネット（黒）＋加算合成＋彩度ブースト」で視認性を保証。
    </div>
  </footer>
</div>

<script>
// ===== UI =====
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d');
const concSlider = document.getElementById('conc');
const concVal = document.getElementById('concVal');
const bgSel = document.getElementById('bgSel');
document.getElementById('resetBtn').addEventListener('click', resetState);
concSlider.addEventListener('input', ()=> concVal.textContent = (+concSlider.value).toFixed(2));
bgSel.addEventListener('change', ()=> { applyBGChrome(); layout(); });

concVal.textContent = (+concSlider.value).toFixed(2);

// ===== Params =====
const PARAM = {
  T: 1600, tau: 1.7, tmax: 1.3, sigma: 8,
  baseAlpha: 0.3,
  snap: 42, blend: 0.97,
  flickerAmp: 30, flickerSpeed: 12.0
};

const LINE_DB = {
  "Li": { name:"Li", lines:[ {lambda:670, a:1.0} ],      target:[255, 58, 58] },
  "Na": { name:"Na", lines:[ {lambda:589, a:1.0} ],      target:[255, 215, 60] },
  "K" : { name:"K",  lines:[ {lambda:404, a:1.1}, {lambda:766, a:0.95}, {lambda:770, a:0.9} ], target:[170, 140, 255] },
  "Ca": { name:"Ca", lines:[ {lambda:622, a:1.0}, {lambda:585, a:0.5} ], target:[255, 120, 60] },
  "Sr": { name:"Sr", lines:[ {lambda:606, a:0.85}, {lambda:669, a:1.0} ], target:[255, 62, 62] },
  "Ba": { name:"Ba", lines:[ {lambda:524, a:1.0}, {lambda:553, a:0.8} ],  target:[160, 250, 70] },
  "Cu": { name:"Cu", lines:[ {lambda:510, a:1.1}, {lambda:515, a:0.9} ],  target:[42, 209, 184] }
};
const ORDER = ["Li","Na","K","Ca","Sr","Ba","Cu"];

const state = {
  burner: { w: 100, h: 150, flameHeight: 200 },
  beakers: [], activeElement: null, activeTimer: 0, time: 0,
  draggingId: null, spectrumRect: null, scale: 1, bg: "black"
};

// ===== Resize & Layout =====
function resizeCanvas(){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const wrap = document.getElementById('stageWrap');
  const availW = Math.min(1100, wrap.clientWidth - 12);
  const availH = Math.max(420, window.innerHeight - 170);
  const isPortrait = window.innerHeight > window.innerWidth;
  const baseW = isPortrait ? 720 : 1000;
  const baseH = isPortrait ? 980 : 600;
  const scale = Math.min(availW / baseW, availH / baseH);
  canvas.width  = Math.floor(baseW * scale * dpr);
  canvas.height = Math.floor(baseH * scale * dpr);
  canvas.style.width  = Math.floor(baseW * scale) + "px";
  canvas.style.height = Math.floor(baseH * scale) + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  state.scale = scale;
  layout();
}
function applyBGChrome(){
  state.bg = bgSel.value;
  const header = document.querySelector('header');
  const footer = document.querySelector('footer');
  const stageWrap = document.getElementById('stageWrap');
  if(state.bg === "black"){
    document.body.style.background = "#000";
    header.style.background = "#0e0e0e"; header.style.color = "#eaeaea"; header.style.borderBottom = "1px solid #171717";
    footer.style.background = "#0e0e0e"; footer.style.color = "#bfbfbf"; footer.style.borderTop = "1px solid #171717";
    stageWrap.style.background = "#000";
  } else {
    document.body.style.background = "#fff";
    header.style.background = "#f6f6f6"; header.style.color = "#111"; header.style.borderBottom = "1px solid #ddd";
    footer.style.background = "#f6f6f6"; footer.style.color = "#444"; footer.style.borderTop = "1px solid #ddd";
    stageWrap.style.background = "#fff";
  }
}
function layout(){
  const W = parseInt(canvas.style.width);
  const H = parseInt(canvas.style.height);
  const cx = W/2;
  const cy = H/2 + 24;
  const s = state.scale;
  state.burner.w = 100 * s;
  state.burner.h = 150 * s;
  state.burner.flameHeight = 200 * s;
  state.burner.x = cx - state.burner.w/2;
  state.burner.y = cy - state.burner.h/2;
  state.spectrumRect = { x: 40*s, y: H - 60*s, w: W - 80*s, h: 28*s };
  const gap = 110*s;
  const totalW = (ORDER.length-1)*gap;
  const startX = cx - totalW/2;
  const y = H - 190*s;
  state.beakers = ORDER.map((k, i)=> ({
    id: k, label: LINE_DB[k].name,
    x: startX + i*gap - 40*s, y, w: 80*s, h: 110*s,
    homeX: startX + i*gap - 40*s, homeY: y,
    liquid: k==="Cu" ? "rgba(100,220,255,0.55)" : "rgba(220,220,255,0.05)",
  }));
}

// ===== Input =====
canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
canvas.addEventListener('mouseup',   onUp);
canvas.addEventListener('touchstart',(e)=>onDown(toMouse(e)), {passive:false});
canvas.addEventListener('touchmove', (e)=>{ onMove(toMouse(e)); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend',  (e)=>onUp(toMouse(e)));

function toMouse(e){
  const t = e.touches && e.touches[0] ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : null);
  const r = canvas.getBoundingClientRect();
  const x = (t ? t.clientX : 0) - r.left;
  const y = (t ? t.clientY : 0) - r.top;
  return { clientX: x + r.left, clientY: y + r.top };
}
function onDown(e){
  const p = getMouse(e);
  const b = pickBeaker(p.x, p.y);
  if(b){ state.draggingId = b.id; state.offsetX = p.x - b.x; state.offsetY = p.y - b.y; }
  state.down = true;
}
function onMove(e){
  const p = getMouse(e);
  if(state.down && state.draggingId){
    const b = state.beakers.find(v=>v.id===state.draggingId);
    if(b){
      b.x = p.x - state.offsetX; b.y = p.y - state.offsetY;
      const ring = dropRingRect();
      const cx = ring.x + ring.w/2, cy = ring.y + ring.h/2;
      const bx = b.x + b.w/2, by = b.y + b.h/2;
      const dist = Math.hypot(bx-cx, by-cy);
      const snap = PARAM.snap * state.scale;
      if(dist < snap){ b.x += (cx - bx)*0.5; b.y += (cy - by)*0.5; }
    }
  }
}
function onUp(e){
  state.down = false;
  if(state.draggingId){
    const b = state.beakers.find(v=>v.id===state.draggingId);
    if(b && rectOverlap(b, dropRingRect())){
      state.activeElement = b.id;
      state.activeTimer = 0;
      state.beakers.forEach(x=>{ x.x = x.homeX; x.y = x.homeY; });
    }
  }
  state.draggingId = null;
}
function getMouse(e){ const r = canvas.getBoundingClientRect(); return { x: (e.clientX - r.left), y: (e.clientY - r.top) }; }
function pickBeaker(x,y){
  for(let i=state.beakers.length-1;i>=0;i--){
    const b = state.beakers[i];
    if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h) return b;
  }
  return null;
}
function rectOverlap(a, b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

// ===== Loop =====
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now-last)/1000); last = now;
  state.time += dt;
  if(state.activeElement && state.activeTimer < PARAM.tmax) state.activeTimer += dt;
  drawAll();
  requestAnimationFrame(loop);
}

// ===== Draw =====
function drawAll(){
  const W = parseInt(canvas.style.width), H = parseInt(canvas.style.height);
  ctx.clearRect(0,0,W,H);
  drawBG(W,H);
  // HUD
  ctx.fillStyle = (state.bg === "black") ? "rgba(255,255,255,0.9)" : "rgba(0,0,0,0.85)";
  ctx.font = `${Math.max(12, 14*state.scale)}px system-ui`;
  const hud = state.activeElement ? `状態: 供給中（${state.activeElement}）` : "状態: 元素未投入 — 下のビーカーを中央へ";
  ctx.fillText(hud, 16*state.scale, 28*state.scale);
  drawDropRing();
  drawBurner();
  const tint = computeFlameColor();
  drawFlame(tint);
  drawSpectrum();
  state.beakers.forEach(drawBeaker);
}

// BG
function drawBG(W, H){
  if(state.bg === "black"){ ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H); }
  else if(state.bg === "white"){ ctx.fillStyle = "#fff"; ctx.fillRect(0,0,W,H); }
  else {
    const sky = ctx.createLinearGradient(0,0,0,H*0.6); sky.addColorStop(0, "#63b3ff"); sky.addColorStop(1, "#e8f5ff");
    ctx.fillStyle = sky; ctx.fillRect(0,0,W,H*0.6);
    const sea = ctx.createLinearGradient(0,H*0.6,0,H*0.88); sea.addColorStop(0, "#3aa8d9"); sea.addColorStop(1, "#0a6fb2");
    ctx.fillStyle = sea; ctx.fillRect(0,H*0.6,W,H*0.28);
    const sand = ctx.createLinearGradient(0,H*0.88,0,H); sand.addColorStop(0, "#f1dc97"); sand.addColorStop(1, "#e9c66a");
    ctx.fillStyle = sand; ctx.fillRect(0,H*0.88,W,H*0.12);
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    drawPalm(60*state.scale, H*0.72, 110*state.scale, H*0.22);
    drawPalm(W-80*state.scale, H*0.74, 120*state.scale, H*0.24);
  }
}
function drawPalm(x, y, trunkH, crownR){
  ctx.save(); ctx.translate(x, y);
  ctx.strokeStyle = "rgba(0,0,0,0.65)"; ctx.lineWidth = 10*state.scale;
  ctx.beginPath(); ctx.moveTo(0,0); ctx.bezierCurveTo(8*state.scale, -trunkH*0.3, -10*state.scale, -trunkH*0.7, 4*state.scale, -trunkH); ctx.stroke();
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  for(let i=0;i<6;i++){ const ang = (-Math.PI/2) + i*(Math.PI/6);
    ctx.beginPath(); ctx.ellipse(Math.cos(ang)*crownR*0.6, -trunkH + Math.sin(ang)*crownR*0.35, 30*state.scale, 8*state.scale, ang, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// Ring
function dropRingRect(){ const b = state.burner; return { x: b.x - 10*state.scale, y: b.y - b.flameHeight - 10*state.scale, w: b.w + 20*state.scale, h: b.flameHeight + 20*state.scale }; }
function drawDropRing(){
  const r = dropRingRect();
  const pulse = 0.5 + 0.5*Math.sin(state.time*3.0);
  const a = 0.22 + 0.28*pulse;
  ctx.strokeStyle = (state.bg==="black") ? `rgba(120,180,255,${a})` : `rgba(0,0,0,${0.2+0.5*pulse})`;
  ctx.lineWidth = 3*state.scale; ctx.setLineDash([8*state.scale,6*state.scale]);
  ctx.strokeRect(r.x, r.y, r.w, r.h); ctx.setLineDash([]);
  ctx.fillStyle = (state.bg==="black") ? `rgba(180,210,255,${0.7*a+0.2})` : "rgba(0,0,0,0.4)";
  ctx.font = `${Math.max(10, 12*state.scale)}px system-ui`; ctx.fillText("ここに入れる", r.x + 6*state.scale, r.y - 8*state.scale);
}

// Burner
function drawBurner(){
  const b = state.burner;
  if(state.bg!=="black"){ ctx.fillStyle = "rgba(0,0,0,0.12)"; } else { ctx.fillStyle = "#141414"; }
  ctx.fillRect(b.x - 60*state.scale, b.y + b.h - 14*state.scale, b.w + 120*state.scale, 18*state.scale);
  ctx.fillStyle = (state.bg!=="black") ? "rgba(0,0,0,0.35)" : "#232323";
  ctx.fillRect(b.x, b.y + b.h - 26*state.scale, b.w, 26*state.scale);
}

// Flame (stronger on light BG)
function drawFlame(tint){
  const b = state.burner;
  const cx = b.x + b.w/2;
  const baseY = b.y + b.h - 26*state.scale;
  const H = b.flameHeight;
  const t = state.time;
  const f = Math.sin(t * 12.0) + 0.5*Math.sin(t * (12.0*0.73 + 0.5));
  const flickerY = (30 * state.scale) * (0.5 + 0.5*f);
  const widen = 1.0 + 0.18*Math.sin(t*5.3);

  // 強力な背面ビネット（白・ハワイ用）
  if(state.bg!=="black"){
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = "rgba(0,0,0,0.38)";
    ctx.beginPath();
    ctx.ellipse(cx, baseY - H*0.42, b.w*1.85, H*1.35, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
  }

  // 合成モード：黒→screen、白/ハワイ→lighter（加算）
  ctx.globalCompositeOperation = (state.bg==="black") ? "screen" : "lighter";

  // ベース炎（白/ハワイは濃度を上げる）
  const baseBoost = (state.bg==="black") ? 1.0 : 1.25;
  const g = ctx.createRadialGradient(cx, baseY- H*0.24, 12*state.scale, cx, baseY- H*0.60, H*1.05);
  const baseA = PARAM.baseAlpha * baseBoost;
  g.addColorStop(0, `rgba(255,230,170,${baseA})`);
  g.addColorStop(0.45, `rgba(255,160,60,${baseA*0.65})`);
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.ellipse(cx, baseY - H*0.42 + flickerY*0.4, b.w*1.18*widen, H*0.92, 0, 0, Math.PI*2);
  ctx.fill();

  // 元素色（白/ハワイで彩度・明るさをさらにブースト）
  if(tint){
    const boost = (state.bg==="black") ? 1.0 : 1.35;
    const coreA = (state.bg==="black") ? 0.98 : 1.00; // ほぼ不透明に
    const glowA = (state.bg==="black") ? 0.62 : 0.82; // グロウも濃く
    const r = Math.min(255, Math.round(tint.r*boost));
    const gch = Math.min(255, Math.round(tint.g*boost));
    const bch = Math.min(255, Math.round(tint.b*boost));

    const g2 = ctx.createRadialGradient(cx, baseY- H*0.34, 8*state.scale, cx, baseY- H*0.72, H*1.30);
    g2.addColorStop(0.0, `rgba(${r},${gch},${bch},${coreA})`);
    g2.addColorStop(0.24, `rgba(${r},${gch},${bch},${glowA})`);
    g2.addColorStop(1.0, "rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.ellipse(cx, baseY - H*0.50 - flickerY*0.15, b.w*1.55*widen, H*1.22, 0, 0, Math.PI*2);
    ctx.fill();

    // 先端の尾も強調
    ctx.fillStyle = `rgba(${r},${gch},${bch},${(state.bg==="black")?0.30:0.55})`;
    ctx.beginPath();
    ctx.ellipse(cx + Math.sin(t*7.7)*6*state.scale, baseY - H*0.82 - flickerY*0.6, b.w*0.65, H*0.35, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalCompositeOperation = "source-over";
}

// Spectrum
function drawSpectrum(){
  const s = state.spectrumRect;
  const boxFill = (state.bg==="black") ? "#050505" : "rgba(255,255,255,0.90)";
  ctx.fillStyle = boxFill; ctx.fillRect(s.x, s.y, s.w, s.h);
  const off = document.createElement('canvas'); off.width = Math.floor(s.w); off.height = Math.floor(s.h);
  const octx = off.getContext('2d'); const img = octx.createImageData(off.width, off.height);
  for(let x=0; x<off.width; x++){
    const lambda = 380 + (x/(off.width-1))*(780-380);
    const intensity = spectralIntensity(lambda);
    const rgb = wavelengthToRGB(lambda);
    for(let y=0; y<off.height; y++){
      const idx = (y*off.width + x) * 4;
      img.data[idx+0] = Math.min(255, Math.floor(rgb.r * intensity));
      img.data[idx+1] = Math.min(255, Math.floor(rgb.g * intensity));
      img.data[idx+2] = Math.min(255, Math.floor(rgb.b * intensity));
      img.data[idx+3] = 255;
    }
  }
  octx.putImageData(img, 0, 0); ctx.drawImage(off, s.x, s.y);
  if(state.activeElement){
    const lines = LINE_DB[state.activeElement].lines;
    lines.forEach(L=>{
      const x = s.x + ((L.lambda-380)/(780-380))*s.w;
      const col = wavelengthToRGB(L.lambda);
      ctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},1.0)`;
      ctx.lineWidth = Math.max(2*state.scale, 2 + L.a*1.2*state.scale);
      ctx.beginPath(); ctx.moveTo(x, s.y); ctx.lineTo(x, s.y+s.h); ctx.stroke();
    });
  }
  const grid = (state.bg==="black") ? "rgba(255,255,255,0.22)" : "rgba(0,0,0,0.25)";
  const text = (state.bg==="black") ? "rgba(255,255,255,0.85)" : "rgba(0,0,0,0.85)";
  ctx.strokeStyle = grid; ctx.lineWidth = 1*state.scale;
  [400,500,600,700].forEach(mark=>{
    const x = s.x + ((mark-380)/(780-380))*s.w;
    ctx.beginPath(); ctx.moveTo(x, s.y); ctx.lineTo(x, s.y+s.h); ctx.stroke();
    ctx.fillStyle = text; ctx.font = `${Math.max(10, 11*state.scale)}px system-ui`;
    ctx.fillText(`${mark} nm`, x-16*state.scale, s.y + s.h + 12*state.scale);
  });
  ctx.strokeStyle = grid; ctx.strokeRect(s.x, s.y, s.w, s.h);
}

// Beaker
function drawBeaker(b){
  ctx.fillStyle = (state.bg==="black") ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.08)";
  ctx.beginPath(); ctx.ellipse(b.x + b.w/2, b.y + b.h + 6*state.scale, b.w*0.6, 8*state.scale, 0, 0, Math.PI*2); ctx.fill();
  const strokeCol = (state.bg==="black") ? "rgba(255,255,255,0.95)" : "rgba(0,0,0,0.95)";
  const fillCol   = (state.bg==="black") ? "rgba(255,255,255,0.05)" : "rgba(0,0,0,0.04)";
  ctx.fillStyle = fillCol; ctx.strokeStyle = strokeCol;
  roundRect(b.x, b.y, b.w, b.h, 10*state.scale, true, true);
  ctx.fillStyle = b.liquid;
  roundRect(b.x+5*state.scale, b.y + b.h*0.52, b.w-10*state.scale, b.h*0.45, 8*state.scale, true, false);
  ctx.fillStyle = (state.bg==="black") ? "#f0f0f0" : "#111";
  ctx.font = `bold ${Math.max(14, 16*state.scale)}px system-ui`;
  ctx.textAlign = "center"; ctx.fillText(b.label, b.x + b.w/2, b.y + 22*state.scale);
}

// Color math
function computeFlameColor(){
  let base = {r:0,g:0,b:0};
  if(state.activeElement){
    const item = LINE_DB[state.activeElement]; const lines = item.lines;
    const C = parseFloat(concSlider.value);
    const T = PARAM.T, tau = PARAM.tau, tmax = PARAM.tmax, sigma = PARAM.sigma;
    const t = Math.min(state.activeTimer, tmax);
    const fT = Math.max(0, T/1600); const decay = Math.exp(-t/tau);
    let R=0,G=0,B=0; const steps = 120;
    for(let i=0;i<=steps;i++){
      const lambda = 380 + (i/steps)*(780-380);
      let I=0; for(const L of lines){ const d = lambda - L.lambda; I += L.a * Math.exp(-(d*d)/(2*sigma*sigma)); }
      I *= C * fT * decay;
      const rgb = wavelengthToRGB(lambda); R += rgb.r * I; G += rgb.g * I; B += rgb.b * I;
    }
    const s = 1.0/steps;
    let spec = { r: clamp((R*s)*1.55, 0, 255), g: clamp((G*s)*1.55, 0, 255), b: clamp((B*s)*1.55, 0, 255) };
    const tgt = { r:item.target[0], g:item.target[1], b:item.target[2] };
    const k = Math.min(1, PARAM.blend * (0.65 + 0.35*C));
    base = { r: Math.round(spec.r*(1-k) + tgt.r*k), g: Math.round(spec.g*(1-k) + tgt.g*k), b: Math.round(spec.b*(1-k) + tgt.b*k) };
  } else {
    base = (state.bg==="black") ? {r:70,g:55,b:35} : {r:130,g:110,b:85};
  }
  return { r: Math.round(base.r), g: Math.round(base.g), b: Math.round(base.b), a: 0.99 };
}
function spectralIntensity(lambda){
  if(!state.activeElement) return 0.02;
  const item = LINE_DB[state.activeElement]; const lines = item.lines;
  const C = parseFloat(concSlider.value);
  const T = PARAM.T, tau = PARAM.tau, tmax = PARAM.tmax, sigma = PARAM.sigma;
  const t = Math.min(state.activeTimer, tmax); const fT = Math.max(0, T/1600); const decay = Math.exp(-t/tau);
  let I=0; for(const L of lines){ const d = lambda - L.lambda; I += L.a * Math.exp(-(d*d)/(2*sigma*sigma)); }
  I *= C * fT * decay; return Math.min(1.0, I*2.0 + 0.02);
}
function wavelengthToRGB(lambda){
  let r=0,g=0,b=0;
  if(lambda >= 380 && lambda < 440){ r = -(lambda - 440) / (440 - 380); g = 0.0; b = 1.0; }
  else if(lambda >= 440 && lambda < 490){ r = 0.0; g = (lambda - 440) / (490 - 440); b = 1.0; }
  else if(lambda >= 490 && lambda < 510){ r = 0.0; g = 1.0; b = -(lambda - 510) / (510 - 490); }
  else if(lambda >= 510 && lambda < 580){ r = (lambda - 510) / (580 - 510); g = 1.0; b = 0.0; }
  else if(lambda >= 580 && lambda < 645){ r = 1.0; g = -(lambda - 645) / (645 - 580); b = 0.0; }
  else if(lambda >= 645 && lambda <= 780){ r = 1.0; g = 0.0; b = 0.0; }
  let factor = 1.0;
  if(lambda >= 380 && lambda < 420){ factor = 0.3 + 0.7*(lambda - 380)/40; }
  else if(lambda >= 700 && lambda <= 780){ factor = 0.3 + 0.7*(780 - lambda)/80; }
  const gamma = 0.8;
  r = Math.pow(Math.max(0,r)*factor, gamma);
  g = Math.pow(Math.max(0,g)*factor, gamma);
  b = Math.pow(Math.max(0,b)*factor, gamma);
  return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
}

// Utils
function clamp(x,minv,maxv){ return Math.max(minv, Math.min(maxv, x)); }
function roundRect(x, y, w, h, r, fill, stroke){
  if(w<2*r) r = w/2; if(h<2*r) r = h/2;
  ctx.beginPath(); ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath(); if(fill) ctx.fill(); if(stroke){ ctx.stroke(); }
}

// Init
function resetState(){
  state.activeElement = null; state.activeTimer = 0; state.time = 0;
  concSlider.value = 0.85; concVal.textContent = (+concSlider.value).toFixed(2);
  applyBGChrome(); resizeCanvas();
}
window.addEventListener('resize', resizeCanvas);
resetState(); requestAnimationFrame(loop);
</script>
</body>
</html>