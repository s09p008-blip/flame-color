<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>炎色反応シミュレーション — Vivid Responsive Edition</title>
<style>
  html, body { margin:0; height:100%; background:#000; color:#eaeaea; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;}
  #app { display:grid; grid-template-rows:auto 1fr auto; height:100vh; }
  header, footer { padding:8px 12px; background:#0e0e0e; border-bottom:1px solid #171717; }
  footer { border-top:1px solid #171717; border-bottom:none; }
  .title { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
  .tag { font-size:12px; padding:2px 8px; border:1px solid #333; border-radius:999px; color:#bdbdbd; }
  #controls { display:flex; align-items:center; gap:12px; padding:6px 0; flex-wrap:wrap; }
  label { font-size:13px; color:#cfcfcf; }
  input[type="range"] { width: 240px; max-width: 56vw; }
  button { background:#181818; color:#eaeaea; border:1px solid #3a3a3a; border-radius:8px; padding:6px 10px; cursor:pointer; }
  button:active { transform: translateY(1px); }
  #stageWrap { display:flex; align-items:center; justify-content:center; padding: 6px 0; }
  canvas { background:#000; border-radius: 12px; border:1px solid #1d1d1d; display:block; width:100%; height:auto; touch-action:none; }
  .legend { font-size:12px; color:#bfbfbf; opacity:0.9; }
  @media (max-width: 640px) {
    input[type="range"]{ width: 160px; }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="title">
      <strong>炎色反応シミュレーション（ドラッグ/スワイプで投入）</strong>
      <span class="tag">Vivid</span>
      <span class="tag">Responsive</span>
      <span class="tag">背景：黒</span>
    </div>
    <div id="controls">
      <label for="conc">濃度 C（mol/L）</label>
      <input id="conc" type="range" min="0.00" max="1.00" step="0.01" value="0.80">
      <span id="concVal">0.80</span>
      <button id="resetBtn">初期化</button>
      <span class="legend">下のビーカーを<b>ドラッグ/スワイプ</b>し、中央の発光リングへ。</span>
    </div>
  </header>

  <div id="stageWrap">
    <canvas id="scene" aria-label="炎色反応ステージ"></canvas>
  </div>

  <footer>
    <div class="legend">
      数理モデル（教育用近似）：I(λ,t)=C·f(T)·Σ a_i·exp(-(λ-λ_i)^2/2σ^2)·exp(-t/τ)。λ[nm], t[s], C[mol/L], σ[nm], τ[s], f(T)=T/1600。
      視認性最優先のため、線スペクトル合成に<strong>ターゲット色補正</strong>を強めにブレンド。
    </div>
  </footer>
</div>

<script>
/* =============================================================
  炎色反応シミュレーション — Vivid Responsive Edition
  ・色の“濁り”を防ぐため、元素色レイヤーを強調しベース炎の寄与を弱めた。
  ・参考色：Li=深赤 / Na=黄 / K=紫 / Ca=橙赤 / Sr=紅 / Ba=黄緑 / Cu=青緑。
  ・スマホ/縦長対応：自動リサイズ＋DPR対応＋タッチドラッグ。
============================================================= */

// ====== キャンバスとUI ======
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d');
const concSlider = document.getElementById('conc');
const concVal = document.getElementById('concVal');
document.getElementById('resetBtn').addEventListener('click', resetState);
concSlider.addEventListener('input', ()=> concVal.textContent = (+concSlider.value).toFixed(2));
concVal.textContent = (+concSlider.value).toFixed(2);

// ====== 内部パラメータ ======
const PARAM = {
  T: 1600,    // K
  tau: 1.8,   // s  少し短くして色変化のレスポンスを良く
  tmax: 1.2,  // s
  sigma: 8,   // nm  線をさらにシャープに
  baseAlpha: 0.35, // ベース炎の強さ（小さいほど元素色が支配）
  snap: 40,   // 吸着距離（px, レイアウト後にスケール）
  blend: 0.90 // ターゲット色への寄せ具合（強め）
};

// ====== 元素の線データ＋ターゲット色（参考色味） ======
const LINE_DB = {
  "Li": { name:"Li⁺", colorName:"深赤", lines:[ {lambda:670, a:1.0} ],      target:[255, 58, 58] },
  "Na": { name:"Na⁺", colorName:"黄",   lines:[ {lambda:589, a:1.0} ],      target:[255, 215, 60] },
  "K" : { name:"K⁺",  colorName:"紫",   lines:[ {lambda:404, a:1.1}, {lambda:766, a:0.95}, {lambda:770, a:0.9} ], target:[170, 140, 255] },
  "Ca": { name:"Ca²⁺",colorName:"橙赤", lines:[ {lambda:622, a:1.0}, {lambda:585, a:0.5} ], target:[255, 120, 60] },
  "Sr": { name:"Sr²⁺",colorName:"紅",   lines:[ {lambda:606, a:0.85}, {lambda:669, a:1.0} ], target:[255, 62, 62] },
  "Ba": { name:"Ba²⁺",colorName:"黄緑", lines:[ {lambda:524, a:1.0}, {lambda:553, a:0.8} ],  target:[160, 250, 70] },
  "Cu": { name:"Cu²⁺",colorName:"青緑", lines:[ {lambda:510, a:1.1}, {lambda:515, a:0.9} ],  target:[42, 209, 184] }
};

// ====== 状態 ======
const state = {
  burner: { w: 100, h: 150, flameHeight: 200 },
  beakers: [],
  activeElement: null,
  activeTimer: 0,
  time: 0,
  draggingId: null,
  mouse: {x:0,y:0,down:false,offsetX:0,offsetY:0},
  spectrumRect: null,
  scale: 1
};

// ====== リサイズ（レスポンシブ/DPR） ======
function resizeCanvas(){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const wrap = document.getElementById('stageWrap');
  const availW = Math.min(1100, wrap.clientWidth - 12);
  const availH = Math.max(420, window.innerHeight - 170);

  // アスペクト比：横長/縦長で基準変更
  const isPortrait = window.innerHeight > window.innerWidth;
  const baseW = isPortrait ? 720 : 1000;
  const baseH = isPortrait ? 980 : 600;

  const scale = Math.min(availW / baseW, availH / baseH);
  canvas.width  = Math.floor(baseW * scale * dpr);
  canvas.height = Math.floor(baseH * scale * dpr);
  canvas.style.width  = Math.floor(baseW * scale) + "px";
  canvas.style.height = Math.floor(baseH * scale) + "px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  state.scale = scale;

  layout();
}

// ====== レイアウト ======
function layout(){
  const W = parseInt(canvas.style.width);
  const H = parseInt(canvas.style.height);
  const cx = W/2;
  const cy = H/2 + 24;
  const s = state.scale;

  state.burner.w = 100 * s;
  state.burner.h = 150 * s;
  state.burner.flameHeight = 200 * s;
  state.burner.x = cx - state.burner.w/2;
  state.burner.y = cy - state.burner.h/2;

  // スペクトル帯（下部）
  state.spectrumRect = { x: 40*s, y: H - 90*s, w: W - 80*s, h: 38*s };

  // ビーカー（中央寄せ・大型化）
  const keys = ["Li","Na","K","Ca","Sr","Ba","Cu"];
  const gap = 110*s;
  const totalW = (keys.length-1)*gap;
  const startX = cx - totalW/2;
  const y = H - 190*s;
  state.beakers = keys.map((k, i)=> ({
    id: k,
    label: LINE_DB[k].name,
    x: startX + i*gap - 40*s,
    y,
    w: 80*s,
    h: 110*s,
    liquid: k==="Cu" ? "rgba(100,220,255,0.55)" : "rgba(220,220,255,0.05)",
  }));
}

// ====== 入力（マウス & タッチ） ======
canvas.addEventListener('mousedown', pointerDown);
canvas.addEventListener('mousemove', pointerMove);
canvas.addEventListener('mouseup',   pointerUp);
canvas.addEventListener('touchstart',(e)=>pointerDown(toMouse(e)), {passive:false});
canvas.addEventListener('touchmove', (e)=>{ pointerMove(toMouse(e)); e.preventDefault(); }, {passive:false});
canvas.addEventListener('touchend',  (e)=>pointerUp(toMouse(e)));

function toMouse(e){
  const t = e.touches && e.touches[0] ? e.touches[0] : (e.changedTouches ? e.changedTouches[0] : null);
  const r = canvas.getBoundingClientRect();
  const x = (t ? t.clientX : 0) - r.left;
  const y = (t ? t.clientY : 0) - r.top;
  return { clientX: x + r.left, clientY: y + r.top };
}

function pointerDown(e){
  const p = getMouse(e);
  const b = pickBeaker(p.x, p.y);
  if(b){
    state.draggingId = b.id;
    state.mouse.offsetX = p.x - b.x;
    state.mouse.offsetY = p.y - b.y;
  }
  state.mouse.down = true;
}
function pointerMove(e){
  const p = getMouse(e);
  state.mouse.x = p.x; state.mouse.y = p.y;
  if(state.mouse.down && state.draggingId){
    const b = state.beakers.find(v=>v.id===state.draggingId);
    if(b){
      b.x = p.x - state.mouse.offsetX;
      b.y = p.y - state.mouse.offsetY;
      // 吸着
      const ring = dropRingRect();
      const cx = ring.x + ring.w/2, cy = ring.y + ring.h/2;
      const bx = b.x + b.w/2, by = b.y + b.h/2;
      const dist = Math.hypot(bx-cx, by-cy);
      const snap = 40 * state.scale;
      if(dist < snap){
        b.x += (cx - bx)*0.5;
        b.y += (cy - by)*0.5;
      }
    }
  }
}
function pointerUp(e){
  state.mouse.down = false;
  if(state.draggingId){
    const b = state.beakers.find(v=>v.id===state.draggingId);
    if(b && rectOverlap(b, dropRingRect())){
      state.activeElement = b.id;
      state.activeTimer = 0;
    }
  }
  state.draggingId = null;
}

function getMouse(e){
  const r = canvas.getBoundingClientRect();
  return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
}
function pickBeaker(x,y){
  for(let i=state.beakers.length-1;i>=0;i--){
    const b = state.beakers[i];
    if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h) return b;
  }
  return null;
}
function rectOverlap(a, b){
  return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
}

// ====== ループ ======
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now-last)/1000);
  last = now;
  state.time += dt;

  if(state.activeElement){
    if(state.activeTimer < PARAM.tmax) state.activeTimer += dt;
  }

  drawAll();
  requestAnimationFrame(loop);
}

// ====== 描画全体 ======
function drawAll(){
  const W = parseInt(canvas.style.width);
  const H = parseInt(canvas.style.height);
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#000"; ctx.fillRect(0,0,W,H);

  // HUD
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.font = `${Math.max(12, 14*state.scale)}px system-ui`;
  const hud = state.activeElement 
    ? `状態: ${state.activeElement} 供給中（${LINE_DB[state.activeElement].colorName}）`
    : "状態: 元素未投入 — 下のビーカーを中央の発光リングへ";
  ctx.fillText(hud, 16*state.scale, 28*state.scale);

  // ドロップターゲット
  drawDropRing();

  // バーナー & 炎
  drawBurner();
  const tint = computeFlameColor();  // 強調された元素色
  drawFlame(tint);

  // スペクトル（色付き線）
  drawSpectrum();

  // ビーカー
  state.beakers.forEach(drawBeaker);
}

// ====== ターゲットリング ======
function dropRingRect(){
  const b = state.burner;
  return { x: b.x - 10*state.scale, y: b.y - b.flameHeight - 10*state.scale, w: b.w + 20*state.scale, h: b.flameHeight + 20*state.scale };
}
function drawDropRing(){
  const r = dropRingRect();
  const pulse = 0.5 + 0.5*Math.sin(state.time*3.0);
  const a = 0.22 + 0.28*pulse;
  ctx.strokeStyle = `rgba(120,180,255,${a})`;
  ctx.lineWidth = 3*state.scale;
  ctx.setLineDash([8*state.scale,6*state.scale]);
  ctx.strokeRect(r.x, r.y, r.w, r.h);
  ctx.setLineDash([]);
  ctx.fillStyle = `rgba(180,210,255,${0.7*a+0.2})`;
  ctx.font = `${Math.max(10, 12*state.scale)}px system-ui`;
  ctx.fillText("ここに入れる", r.x + 6*state.scale, r.y - 8*state.scale);
}

// ====== バーナー＆炎 ======
function drawBurner(){
  const b = state.burner;
  ctx.fillStyle = "#141414";
  ctx.fillRect(b.x - 60*state.scale, b.y + b.h - 14*state.scale, b.w + 120*state.scale, 18*state.scale);
  ctx.fillStyle = "#232323";
  ctx.fillRect(b.x, b.y + b.h - 26*state.scale, b.w, 26*state.scale);
}

function drawFlame(tint){
  const b = state.burner;
  const cx = b.x + b.w/2;
  const baseY = b.y + b.h - 26*state.scale;
  const H = b.flameHeight;
  const flicker = 0.06*Math.sin(state.time*10) + 0.06*Math.random();

  // ベース炎（弱めにして濁りを抑制）
  const g = ctx.createRadialGradient(cx, baseY- H*0.22, 12*state.scale, cx, baseY- H*0.60, H*1.05);
  g.addColorStop(0, `rgba(255,230,170,${PARAM.baseAlpha})`);
  g.addColorStop(0.45, `rgba(255,160,60,${PARAM.baseAlpha*0.6})`);
  g.addColorStop(1, "rgba(0,0,0,0)");
  ctx.globalCompositeOperation = "screen";
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.ellipse(cx, baseY - H*0.42 + flicker*24*state.scale, b.w*1.2, H*0.95, 0, 0, Math.PI*2);
  ctx.fill();

  // 元素色の発光レイヤー（強め・彩度優先）
  if(tint){
    const colCore = `rgba(${tint.r},${tint.g},${tint.b},0.95)`;
    const colGlow = `rgba(${tint.r},${tint.g},${tint.b},0.55)`;
    const g2 = ctx.createRadialGradient(cx, baseY- H*0.35, 8*state.scale, cx, baseY- H*0.70, H*1.25);
    g2.addColorStop(0.0, colCore);
    g2.addColorStop(0.25, colGlow);
    g2.addColorStop(1.0, "rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.ellipse(cx, baseY - H*0.50, b.w*1.55, H*1.20, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalCompositeOperation = "source-over";
}

// ====== スペクトル（色帯＋色付き縦線） ======
function drawSpectrum(){
  const s = state.spectrumRect;
  ctx.fillStyle = "#050505"; ctx.fillRect(s.x, s.y, s.w, s.h);

  // 連続帯（現在元素に応じた強度）
  const off = document.createElement('canvas');
  off.width = Math.floor(s.w); off.height = Math.floor(s.h);
  const octx = off.getContext('2d');
  const img = octx.createImageData(off.width, off.height);
  for(let x=0; x<off.width; x++){
    const lambda = 380 + (x/(off.width-1))*(780-380);
    const intensity = spectralIntensity(lambda);
    const rgb = wavelengthToRGB(lambda);
    for(let y=0; y<off.height; y++){
      const idx = (y*off.width + x) * 4;
      img.data[idx+0] = Math.min(255, Math.floor(rgb.r * intensity));
      img.data[idx+1] = Math.min(255, Math.floor(rgb.g * intensity));
      img.data[idx+2] = Math.min(255, Math.floor(rgb.b * intensity));
      img.data[idx+3] = 255;
    }
  }
  octx.putImageData(img, 0, 0);
  ctx.drawImage(off, s.x, s.y);

  // 色付き縦線（発光線）
  if(state.activeElement){
    const lines = LINE_DB[state.activeElement].lines;
    lines.forEach(L=>{
      const x = s.x + ((L.lambda-380)/(780-380))*s.w;
      const col = wavelengthToRGB(L.lambda);
      ctx.strokeStyle = `rgba(${col.r},${col.g},${col.b},1.0)`;
      ctx.lineWidth = Math.max(2*state.scale, 2 + L.a*1.2*state.scale);
      ctx.beginPath(); ctx.moveTo(x, s.y); ctx.lineTo(x, s.y+s.h); ctx.stroke();
    });
  }

  // 目盛り
  ctx.strokeStyle = "rgba(255,255,255,0.2)";
  ctx.lineWidth = 1*state.scale;
  [400,500,600,700].forEach(mark=>{
    const x = s.x + ((mark-380)/(780-380))*s.w;
    ctx.beginPath(); ctx.moveTo(x, s.y); ctx.lineTo(x, s.y+s.h); ctx.stroke();
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.font = `${Math.max(10, 11*state.scale)}px system-ui`;
    ctx.fillText(`${mark} nm`, x-16*state.scale, s.y + s.h + 12*state.scale);
  });

  ctx.strokeStyle = "rgba(255,255,255,0.28)";
  ctx.strokeRect(s.x, s.y, s.w, s.h);
}

// ====== ビーカー ======
function drawBeaker(b){
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  ctx.beginPath();
  ctx.ellipse(b.x + b.w/2, b.y + b.h + 6*state.scale, b.w*0.6, 8*state.scale, 0, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = "rgba(200,200,255,0.10)";
  ctx.strokeStyle = "rgba(210,210,255,0.25)";
  roundRect(b.x, b.y, b.w, b.h, 10*state.scale, true, true);

  ctx.fillStyle = b.liquid;
  roundRect(b.x+5*state.scale, b.y + b.h*0.52, b.w-10*state.scale, b.h*0.45, 8*state.scale, true, false);

  ctx.fillStyle = "#ededed";
  ctx.font = `bold ${Math.max(14, 16*state.scale)}px system-ui`;
  ctx.fillText(b.id, b.x + b.w/2 - 10*state.scale, b.y + 22*state.scale);
  ctx.font = `${Math.max(10, 11*state.scale)}px system-ui`;
  ctx.fillStyle = "rgba(230,230,230,0.8)";
  ctx.fillText(LINE_DB[b.id].colorName, b.x + b.w/2 - 16*state.scale, b.y + 38*state.scale);

  if(state.draggingId === b.id){
    ctx.strokeStyle = "rgba(150,200,255,0.6)";
    ctx.setLineDash([5*state.scale,3*state.scale]);
    ctx.strokeRect(b.x-3*state.scale, b.y-3*state.scale, b.w+6*state.scale, b.h+6*state.scale);
    ctx.setLineDash([]);
  }
}

// ====== 色計算：スペクトル合成＋ターゲット色補正（強め） ======
function computeFlameColor(){
  // ベースはほぼゼロ寄り（濁り防止）
  let base = {r:0,g:0,b:0};

  if(state.activeElement){
    const item = LINE_DB[state.activeElement];
    const lines = item.lines;
    const C = parseFloat(concSlider.value);
    const T = PARAM.T, tau = PARAM.tau, tmax = PARAM.tmax, sigma = PARAM.sigma;
    const t = Math.min(state.activeTimer, tmax);
    const fT = Math.max(0, T/1600);
    const decay = Math.exp(-t/tau);

    // スペクトル合成
    let R=0,G=0,B=0;
    const steps = 120;
    for(let i=0;i<=steps;i++){
      const lambda = 380 + (i/steps)*(780-380);
      let I=0;
      for(const L of lines){
        const d = lambda - L.lambda;
        I += L.a * Math.exp(-(d*d)/(2*sigma*sigma));
      }
      I *= C * fT * decay;
      const rgb = wavelengthToRGB(lambda);
      R += rgb.r * I; G += rgb.g * I; B += rgb.b * I;
    }
    const s = 1.0/steps;
    let spec = { r: clamp((R*s)*1.4, 0, 255), g: clamp((G*s)*1.4, 0, 255), b: clamp((B*s)*1.4, 0, 255) };

    // ターゲット色補正（強め）
    const tgt = { r:item.target[0], g:item.target[1], b:item.target[2] };
    const k = Math.min(1, PARAM.blend * (0.6 + 0.4*C)); // 濃度高いほど寄せる
    const mix = {
      r: Math.round(spec.r*(1-k) + tgt.r*k),
      g: Math.round(spec.g*(1-k) + tgt.g*k),
      b: Math.round(spec.b*(1-k) + tgt.b*k)
    };

    base = mix;
  } else {
    // 未投入時：ごく弱い温色
    base = {r:70,g:55,b:35};
  }

  return { r: Math.round(base.r), g: Math.round(base.g), b: Math.round(base.b), a: 0.98 };
}

// ====== スペクトル強度 ======
function spectralIntensity(lambda){
  if(!state.activeElement) return 0.02;
  const item = LINE_DB[state.activeElement];
  const lines = item.lines;
  const C = parseFloat(concSlider.value);
  const T = PARAM.T, tau = PARAM.tau, tmax = PARAM.tmax, sigma = PARAM.sigma;
  const t = Math.min(state.activeTimer, tmax);
  const fT = Math.max(0, T/1600);
  const decay = Math.exp(-t/tau);

  let I=0;
  for(const L of lines){
    const d = lambda - L.lambda;
    I += L.a * Math.exp(-(d*d)/(2*sigma*sigma));
  }
  I *= C * fT * decay;
  return Math.min(1.0, I*1.9 + 0.02);
}

// ====== λ→RGB 近似 ======
function wavelengthToRGB(lambda){
  let r=0,g=0,b=0;
  if(lambda >= 380 && lambda < 440){
    r = -(lambda - 440) / (440 - 380);
    g = 0.0; b = 1.0;
  } else if(lambda >= 440 && lambda < 490){
    r = 0.0; g = (lambda - 440) / (490 - 440);
    b = 1.0;
  } else if(lambda >= 490 && lambda < 510){
    r = 0.0; g = 1.0;
    b = -(lambda - 510) / (510 - 490);
  } else if(lambda >= 510 && lambda < 580){
    r = (lambda - 510) / (580 - 510);
    g = 1.0; b = 0.0;
  } else if(lambda >= 580 && lambda < 645){
    r = 1.0; g = -(lambda - 645) / (645 - 580);
    b = 0.0;
  } else if(lambda >= 645 && lambda <= 780){
    r = 1.0; g = 0.0; b = 0.0;
  } else {
    r = g = b = 0.0;
  }
  let factor = 1.0;
  if(lambda >= 380 && lambda < 420){
    factor = 0.3 + 0.7*(lambda - 380)/40;
  } else if(lambda >= 700 && lambda <= 780){
    factor = 0.3 + 0.7*(780 - lambda)/80;
  }
  const gamma = 0.8;
  r = Math.pow(r*factor, gamma);
  g = Math.pow(g*factor, gamma);
  b = Math.pow(b*factor, gamma);
  return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
}

// ====== ユーティリティ ======
function clamp(x,minv,maxv){ return Math.max(minv, Math.min(maxv, x)); }
function roundRect(x, y, w, h, r, fill, stroke){
  if(w<2*r) r = w/2;
  if(h<2*r) r = h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke){ ctx.stroke(); }
}

// ====== 初期化 ======
function resetState(){
  state.activeElement = null;
  state.activeTimer = 0;
  state.time = 0;
  concSlider.value = 0.80;
  concVal.textContent = (+concSlider.value).toFixed(2);
  resizeCanvas();
}
window.addEventListener('resize', resizeCanvas);
resetState();
requestAnimationFrame(loop);
</script>
</body>
</html>